# galaxy
author Utkarsh
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Cosmic Immersion</title>
    <style>
        :root {
            --neon: #00f3ff;
            --glass: rgba(255, 255, 255, 0.03);
            --font: 'Rajdhani', sans-serif; /* Sci-fi font fallback */
        }

        body { 
            margin: 0; overflow: hidden; background: #000; 
            font-family: sans-serif;
        }

        /* Full Screen Canvas */
        #universe { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
<meta name="google-site-verification" content="e8dOJvQBpNxj8iT81cUX8-GMfID87E-DVeiGuYPl2Rs" />
        /* Minimal HUD */
        #hud {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
            padding: 40px; box-sizing: border-box;
        }

        .hud-text {
            color: rgba(255,255,255,0.8);
            text-transform: uppercase;
            letter-spacing: 4px;
            font-size: 0.8rem;
            text-shadow: 0 0 10px var(--neon);
            opacity: 0.7;
        }

        .center-guide {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 200px; height: 200px;
            border: 1px solid rgba(255,255,255,0.05);
            border-radius: 50%;
            pointer-events: none;
            display: flex; align-items: center; justify-content: center;
        }
        .center-guide::after {
            content: '+'; color: rgba(255,255,255,0.2); font-size: 20px;
        }

        /* Camera Feed (Cinematic & Hidden mostly) */
        .cam-wrapx {
            position: absolute; bottom: 30px; right: 30px;
            width: 140px; height: 100px;
            border-radius: 8px; overflow: hidden;
            border: 1px solid rgba(255,255,255,0.1);
            transform: scaleX(-1);
            opacity: 0.5; transition: opacity 0.3s;
        }
        .cam-wrapx:hover { opacity: 1; }
        video { width: 100%; height: 100%; object-fit: cover; filter: contrast(1.2) grayscale(0.5); }

        /* Status Indicators */
        .status-line {
            position: absolute; bottom: 30px; left: 30px;
            display: flex; flex-direction: column; gap: 5px;
        }
        .bar { width: 100px; height: 2px; background: rgba(255,255,255,0.1); overflow: hidden; }
        .bar-fill { height: 100%; background: var(--neon); width: 0%; transition: width 0.1s; box-shadow: 0 0 10px var(--neon); }

        /* Loader */
        #loader {
            position: fixed; inset: 0; background: #000; z-index: 100;
            display: flex; justify-content: center; align-items: center; flex-direction: column;
            transition: opacity 1s ease-out;
        }
        .nebula-loader {
            width: 60px; height: 60px; border-radius: 50%;
            background: radial-gradient(circle, var(--neon), transparent);
            filter: blur(10px); animation: pulse 2s infinite;
        }
        @keyframes pulse { 0% { opacity: 0.3; transform: scale(0.8); } 50% { opacity: 1; transform: scale(1.2); } 100% { opacity: 0.3; transform: scale(0.8); } }

    </style>
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
            "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
        }
    }
    </script>
</head>
<body>

    <div id="loader">
        <div class="nebula-loader"></div>
        <div style="color: #444; margin-top: 20px; font-size: 0.8rem; letter-spacing: 2px;">GENERATING GALAXY...</div>
    </div>

    <div id="universe"></div>

    <div id="hud">
        <div class="hud-text">Immersive Engine v4</div>
        <div class="center-guide"></div>
        
        <div class="status-line">
            <div class="hud-text" style="font-size: 0.6rem; margin-bottom:4px;">WARP DRIVE</div>
            <div class="bar"><div class="bar-fill" id="warp-bar"></div></div>
        </div>

        <div class="cam-wrapx">
            <video id="webcam" autoplay playsinline muted></video>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // --- Config for "Feel" ---
        const config = {
            count: 25000, 
            galaxyRadius: 30,
            camSpeed: 0.05,
            isMobile: window.innerWidth < 768
        };
        
        if(config.isMobile) config.count = 10000;

        // --- 1. Scene & Cinematic Camera ---
        const container = document.getElementById('universe');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.03); // Deep space fog

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 10;
        camera.position.y = 2;

        const renderer = new THREE.WebGLRenderer({ powerPreference: "high-performance", antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        container.appendChild(renderer.domElement);

        // --- 2. Post-Processing (The "Dreamy" Look) ---
        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        // Heavy Bloom for that "Nebula" glow
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.strength = 2.0; 
        bloomPass.radius = 0.5; 
        bloomPass.threshold = 0.1;
        composer.addPass(bloomPass);

        // --- 3. The Magical Shader (Curl Noise + Warp) ---
        const uniforms = {
            uTime: { value: 0 },
            uSpeed: { value: 0.2 }, // Normal flow speed
            uWarp: { value: 0 },    // Warp drive intensity (0 to 1)
            uMouse: { value: new THREE.Vector3(0,0,0) },
            uColor1: { value: new THREE.Color('#00f3ff') }, // Cyan
            uColor2: { value: new THREE.Color('#8a2be2') }  // Purple
        };

        const material = new THREE.ShaderMaterial({
            uniforms: uniforms,
            vertexShader: `
                uniform float uTime;
                uniform float uSpeed;
                uniform float uWarp;
                uniform vec3 uMouse;
                
                attribute float aSize;
                attribute float aRandom;
                attribute vec3 aOffset; // Initial random position

                varying float vAlpha;
                varying vec3 vColor;
                varying float vDist;

                // --- CURL NOISE FUNCTION (Fluid motion) ---
                vec3 snoiseVec3( vec3 x ){
                    float s  = sin(x.x); float c  = cos(x.y);
                    return vec3(c, s, -c); // Simplified pseudo-random vector
                }
                
                vec3 curlNoise( vec3 p ){
                    const float e = 0.1;
                    vec3 dx = vec3( e   , 0.0 , 0.0 );
                    vec3 dy = vec3( 0.0 , e   , 0.0 );
                    vec3 dz = vec3( 0.0 , 0.0 , e   );
                    
                    vec3 p_x0 = snoiseVec3( p - dx );
                    vec3 p_x1 = snoiseVec3( p + dx );
                    vec3 p_y0 = snoiseVec3( p - dy );
                    vec3 p_y1 = snoiseVec3( p + dy );
                    vec3 p_z0 = snoiseVec3( p - dz );
                    vec3 p_z1 = snoiseVec3( p + dz );

                    float x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;
                    float y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;
                    float z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;
                    
                    const float divisor = 1.0 / ( 2.0 * e );
                    return normalize( vec3( x , y , z ) * divisor );
                }

                void main() {
                    vec3 pos = position;

                    // 1. Fluid Rotation (Curl)
                    // We move particles along a curl field based on time
                    vec3 noise = curlNoise(pos * 0.2 + uTime * 0.1);
                    pos += noise * (1.0 - uWarp) * 2.0; // Normal floating

                    // 2. Interaction (Mouse/Hand attraction)
                    // If mouse active, gently pull towards center
                    if(uMouse.z > 0.0) {
                        vec3 target = vec3(uMouse.x * 20.0, uMouse.y * 10.0, 0.0);
                        vec3 dir = target - pos;
                        float d = length(dir);
                        if(d < 10.0) {
                            pos += normalize(dir) * (10.0 - d) * 0.1;
                        }
                    }

                    // 3. WARP DRIVE EFFECT (The "Out of World" part)
                    // When uWarp increases, stretch Z and pull X/Y closer
                    float warpZ = uWarp * 40.0;
                    // Move towards camera fast
                    pos.z += mod(uTime * 20.0 * uWarp, 50.0); 
                    if(pos.z > 20.0) pos.z -= 60.0; // Loop back
                    
                    // Stretch lines
                    float stretch = 1.0 + uWarp * 5.0;

                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                    gl_Position = projectionMatrix * mvPosition;

                    // Size calculation
                    float size = aSize * (100.0 / -mvPosition.z);
                    gl_PointSize = size * max(1.0, stretch * 0.5); // Thin lines when warping

                    // Color passing
                    vDist = length(pos) / 20.0;
                    vAlpha = 0.6 + 0.4 * sin(uTime + aRandom * 10.0);
                }
            `,
            fragmentShader: `
                uniform vec3 uColor1;
                uniform vec3 uColor2;
                uniform float uWarp;
                
                varying float vAlpha;
                varying float vDist;

                void main() {
                    vec2 coord = gl_PointCoord - vec2(0.5);
                    
                    // Shape: Circle normally, Line during Warp
                    float dist = length(coord);
                    
                    // Crop to circle
                    if(dist > 0.5 && uWarp < 0.1) discard;
                    
                    // Soft glow
                    float strength = 1.0 - (dist * 2.0);
                    strength = pow(strength, 2.0);

                    // Mix Colors based on distance from center
                    vec3 color = mix(uColor1, uColor2, vDist);
                    
                    // Make it white-hot in center
                    color += vec3(strength * 0.5);

                    gl_FragColor = vec4(color, strength * vAlpha);
                }
            `,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        // --- 4. Geometry (The Galaxy) ---
        const geometry = new THREE.BufferGeometry();
        const positions = [];
        const sizes = [];
        const randoms = [];

        // Create a Spiral Galaxy distribution
        for(let i=0; i<config.count; i++) {
            // Spiral arms
            const branches = 3;
            const radius = Math.random() * config.galaxyRadius;
            const spinAngle = radius * 0.5;
            const branchAngle = (i % branches) * ((Math.PI * 2) / branches);
            
            const randomX = Math.pow(Math.random(), 3) * (Math.random() < 0.5 ? 1 : -1) * 3;
            const randomY = Math.pow(Math.random(), 3) * (Math.random() < 0.5 ? 1 : -1) * 3;
            const randomZ = Math.pow(Math.random(), 3) * (Math.random() < 0.5 ? 1 : -1) * 3;

            const x = Math.cos(branchAngle + spinAngle) * radius + randomX;
            const y = randomY * 1.5; // Flatter y
            const z = Math.sin(branchAngle + spinAngle) * radius + randomZ - 10; // Push back

            positions.push(x, y, z);
            sizes.push(Math.random() * 2.0 + 0.5);
            randoms.push(Math.random());
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('aSize', new THREE.Float32BufferAttribute(sizes, 1));
        geometry.setAttribute('aRandom', new THREE.Float32BufferAttribute(randoms, 1));

        const galaxy = new THREE.Points(geometry, material);
        scene.add(galaxy);

        // --- 5. Logic & Animation ---
        const clock = new THREE.Clock();
        
        // Input State (Smoothed)
        const input = {
            warp: 0,     // Target Warp
            currWarp: 0, // Current Smoothed Warp
            mx: 0, my: 0,
            currMx: 0, currMy: 0,
            hasHand: false
        };

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            // Smooth Interpolation (The secret to "Silky Smooth" feel)
            // We move currWarp towards input.warp slowly (0.05 factor)
            input.currWarp += (input.warp - input.currWarp) * 0.05;
            input.currMx += (input.mx - input.currMx) * 0.05;
            input.currMy += (input.my - input.currMy) * 0.05;

            // Update Shader
            uniforms.uTime.value = time;
            uniforms.uWarp.value = input.currWarp;
            uniforms.uMouse.value.set(input.currMx, input.currMy, input.hasHand ? 1 : 0);

            // Camera Float
            // The camera gently orbits based on mouse position
            camera.position.x += (input.currMx * 5 - camera.position.x) * 0.02;
            camera.position.y += (input.currMy * 2 - camera.position.y) * 0.02;
            camera.lookAt(0, 0, -10); // Look deep into space

            // UI Update
            document.getElementById('warp-bar').style.width = (input.currWarp * 100) + '%';

            composer.render();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- 6. AI & Input Handling ---
        const video = document.getElementById('webcam');
        let landmarker;
        let lastTime = -1;

        async function initVision() {
            try {
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
                landmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numHands: 1
                });
                
                const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 320, height: 240 } });
                video.srcObject = stream;
                video.addEventListener("loadeddata", () => {
                    // Hide loader with fade
                    const l = document.getElementById('loader');
                    l.style.opacity = 0;
                    setTimeout(()=>l.style.display='none', 1000);
                    
                    detectLoop();
                });
            } catch(e) {
                console.error(e);
                alert("Camera error. Use mouse to interact.");
                document.getElementById('loader').style.display='none';
            }
        }

        function detectLoop() {
            requestAnimationFrame(detectLoop);
            if(!landmarker || video.currentTime === lastTime) return;
            lastTime = video.currentTime;
            
            const res = landmarker.detectForVideo(video, performance.now());
            
            if(res.landmarks.length > 0) {
                input.hasHand = true;
                const hand = res.landmarks[0];
                
                // 1. Calculate Openness (Fist vs Palm)
                // Wrist(0) to Tip(12)
                const wrist = hand[0];
                const tip = hand[12]; // Middle finger tip
                const dist = Math.hypot(tip.x - wrist.x, tip.y - wrist.y);
                
                // Dist < 0.25 usually means Fist (Warp Drive!)
                if(dist < 0.25) {
                    input.warp = 1.0; // Engage Warp
                } else {
                    input.warp = 0.0; // Floating
                }

                // 2. Position (0-1 -> -1 to 1)
                const palm = hand[9];
                input.mx = (1 - palm.x) * 2 - 1; 
                input.my = -(palm.y * 2 - 1);

            } else {
                input.hasHand = false;
                input.warp = 0;
                // Auto drift if no hand
                input.mx = Math.sin(performance.now()*0.001) * 0.3;
            }
        }

        // Mouse fallback
        window.addEventListener('mousemove', (e) => {
            if(input.hasHand) return;
            input.mx = (e.clientX / window.innerWidth) * 2 - 1;
            input.my = -(e.clientY / window.innerHeight) * 2 + 1;
        });
        
        window.addEventListener('mousedown', () => input.warp = 1);
        window.addEventListener('mouseup', () => input.warp = 0);

        initVision();
        animate();

    </script>
</body>
</html>
